<!doctype html>
<html>
    <head>
        <title>CS 184 Project 1 Write-Up</title>
    </head>
    <body>
        <h1>CS 184 Project 1 Write-Up</h1>
        <h2>Task 1</h2>
        <h2>Task 2</h2>
        <h2>Task 3</h2>
        <h2>Task 4</h2>
        <h2>Task 5</h2>
            <p>
                Pixel sampling uses original image data to determine pixel color value. There are two pixel sampling methods: nearest sampling and bilinear sampling. 
                Nearest sampling finds the closest pixel to the one being rendered and selects its color from the original image. 
                Bilinear sampling accounts for the color values of the four nearest pixels in the original image. Then use linear interpolations to take the weighted average of these four values.
            </p>
            <p>
                In our implementation of pixel sampling, we create a bounding box and perform supersampling just like previous tasks. 
                Then, we find the corresponding barycentric coordinates of the pixel using the formula given in lecture. 
                Scale the coordinates relative to the mipmap width and height. Depending on which pixel sampling is being used, the remaining algorithm differs. 
                For nearest sampling, we round the scaled coordinates to find the nearest pixel and retrieve its color. 
                For bilinear sampling, we find the 4 neighboring pixels by taking the floor and ceil of the coordinates. 
                Do two horizontal linear interpolations using these 4 pixels as shown in the lecture. 
                Then use these results to do a final vertical linear interpolation to retrieve the weighted color value. 
            </p>
            <h4>Sample Rate: 1 per pixel</h4>
            <p>
                When there are rapid changes in color, bilinear sampling produces much smoother images. Nearest sampling is more blocky and jaggy. 
                This is because bilinear sampling takes the weighted average of nearby neighboring pixels and chooses intermediate color values that transition between one color to another nicely. 
                Nearest sampling, on the other hand, simply picks the color of the closest pixel, so it will result in more noticeable jagged edges.
            </p>
            <img src="writeup_img/task5_nearest1.png" width="75%">
            <img src="writeup_img/task5_bilinear1.png" width="75%">
            <h4>Sample Rate: 16 per pixel</h4>
            <p>
                At a higher sample rate, nearest sampling produces smoother edges. This is the result of supersampling as explained in task 2. 
                However, its difference from bilinear sampling is still very apparent; bilinear sampling takes account into the distance between pixels and use the proportional distance to determine more accurate intermediate color values.
            </p>
            <img src="writeup_img/task5_nearest16.png" width="75%">
            <img src="writeup_img/task5_bilinear16.png" width="75%">
        <h2>Task 6</h2>
            <p>
                Level sampling sample data at different levels of detail. For textures that are closer to the camera, higher levels of detail are used (ie. bigger mipmap). 
                For textures that are further away, lower levels of detail are used (ie. smaller mipmap). This helps to conserve memory and processing resources and create better images.
            </p>
            <p>
                Same as before, we calculate barycentric coordinates for pixel (x, y). Now we also find the barycentric coordinates for (x+1, y) and (x, y+1).
                Then, the algorithm differs depending on the sampling method. 
                For level zero sampling, we set level equal to zero and uses the highest resolution mipmap to perform pixel sampling.
                For nearest sampling, we calculate mipmap level using the formula given in lecture, and then round the resulting value to get the nearest level.
                For linear sampling, we also calculate mipmap level, but we take the floor of the resulting value to get the lower level.
                Then add one to it to get the higher mipmap level. Perform pixel sampling using each level and do linear interpolation with the results to get the weighted average. 
            </p>
            <p>
                Supersampling is the slowest technique because it not only require multiple samples per pixel, but also at a higher resolution than the final output. 
                Thus, it also uses the most memory. However, supersampling generally provides the most antialiasing power because it uses the highest resolution.
                Pixel sampling is the fastest technique and uses the least amount of memory. However, it provides the least antialiasing power.
                Level sampling is the most cost-effective. It uses more memory than pixel sampling because it needs to store mipmaps of different levels, 
                but less than supersampling because the mipmaps are lower resolutions.
                It is more efficient by using lower resolution for faraway objects and higher resolution of closer ones that require more details. 
                It is generally a happy medium between pixel sampling and supersampling in providing antialiasing. 
            </p>
            <h4>Level Zero Sampling</h4>
            With level zero sampling and switching pixel sampling methods, the images clearly show that bilinear sampling provides better antialiasing.
            <img src="writeup_img/task6_zero_nearest.png" width="75%">
            <img src="writeup_img/task6_zero_bilinear.png" width="75%">

            <h4>Nearest Sampling</h4>
            The L_NEAREST and P_LINEAR combination produced the smoothest image. 
            L_NEAREST blurs the image more and shows less texture details in the pixel inspector because the selected object is farther away. 
            <img src="writeup_img/task6_nearest_nearest.png" width="75%">
            <img src="writeup_img/task6_nearest_bilinear.png" width="75%">
    </body>
</html>