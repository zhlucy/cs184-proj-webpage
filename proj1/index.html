<!doctype html>
<html>
    <head>
        <title>CS 184 Project 1 Write-Up</title>
    </head>
    <body>
        <h1>CS 184 Project 1 Write-Up</h1>
        <h2>Task 1</h2>
            <p>
                The first thing we determined when creating our triangles was the winding order of the triangle. In order to determine this, we created a helper function called inside, which determined whether
                a point was inside a triangle by checking to see if that point was above all three lines of the triangle, which was determined using the function shown in lecture. To actually determine the winding order,
                we tested to see if the centroid of the triangle, which is guaranteed to be inside any triangle, was inside the triangle in one winding order. If the centroid was inside, this meant that our winding order was correct;
                if the centroid was outside, then we simply used the other winding order. Using the winding order, we created our three lines to get our triangle. To rasterize the triangle, we would find the minimum and maximum x and y coordinates
                that the triangle was bounded in and we iterated over these x and y coordinates (which included the minimum and maximum values for x and y) and checked to see if each (x + 0.5, y + 0.5) coordinate was inside the triangle. 
                If it was, this meant we would color in (x,y); otherwise, we wouldn't. 
            </p>
            <p>
                Our rasterization algorithm is no worse than one that checks each sample within the bounding box of the triangle, as our algorithm uses this method. We find the minimum and maximum x and y coordinates that the triangle
                can be in, and we iterate over those x and y coordinates.
            </p>
        <h2>Task 2</h2>
            <p>
                Our approach for supersampling was to scale our sample_buffer according to the sample_rate (which was like rasterizing the image at a "higher resolution"). We would then sample at an offset that was different than 0.5, as we had to 
                account for sampling rate since we want the middle of the smaller squares during supersampling. We then checked to see if a point was inside the triangle and then convert indices to sample_buffer coordinates to color it. Other than those modifications,
                our supersampling algorithm was exactly the same as the one described in Task 1. Supersampling renders the image at a higher resolution and then downsampling it to the desired resolution; it is useful because it helps reduce aliasing and jaggies, which 
                makes our image look more smoother and visually pleasing. We used supersampling to antialias our triangles because we sampled at a higher resolution before downsampling, which got rid of the jaggies that we saw in Task 1.
                
            </p>
        <h2>Task 3</h2>
        <h2>Task 4</h2>
        <h2>Task 5</h2>
            <p>
                Pixel sampling uses original image data to determine pixel color value. There are two pixel sampling methods: nearest sampling and bilinear sampling. 
                Nearest sampling finds the closest pixel to the one being rendered and selects its color from the original image. 
                Bilinear sampling accounts for the color values of the four nearest pixels in the original image. Then use linear interpolations to take the weighted average of these four values.
            </p>
            <p>
                In our implementation of pixel sampling, we create a bounding box and perform supersampling just like previous tasks. 
                Then, we find the corresponding barycentric coordinates of the pixel using the formula given in lecture. 
                Scale the coordinates relative to the mipmap width and height. Depending on which pixel sampling is being used, the remaining algorithm differs. 
                For nearest sampling, we round the scaled coordinates to find the nearest pixel and retrieve its color. 
                For bilinear sampling, we find the 4 neighboring pixels by taking the floor and ceil of the coordinates. 
                Do two horizontal linear interpolations using these 4 pixels as shown in the lecture. 
                Then use these results to do a final vertical linear interpolation to retrieve the weighted color value. 
            </p>
            <h4>Sample Rate: 1 per pixel</h4>
            <p>
                When there are rapid changes in color, bilinear sampling produces much smoother images. Nearest sampling is more blocky and jaggy. 
                This is because bilinear sampling takes the weighted average of nearby neighboring pixels and chooses intermediate color values that transition between one color to another nicely. 
                Nearest sampling, on the other hand, simply picks the color of the closest pixel, so it will result in more noticeable jagged edges.
            </p>
            <img src="writeup_img/task5_nearest1.png">
            <img src="writeup_img/task5_bilinear1.png">
            <h4>Sample Rate: 16 per pixel</h4>
            <p>
                At a higher sample rate, nearest sampling produces smoother edges. This is the result of supersampling as explained in task 2. 
                However, its difference from bilinear sampling is still very apparent; bilinear sampling takes account into the distance between pixels and use the proportional distance to determine more accurate intermediate color values.
            </p>
            <img src="writeup_img/task5_nearest16.png">
            <img src="writeup_img/task5_bilinear16.png">
        <h2>Task 6</h2>
            <p>
                Level sampling sample data at different levels of detail. For textures that are closer to the camera, higher levels of detail are used (ie. bigger mipmap). 
                For textures that are further away, lower levels of detail are used (ie. smaller mipmap). This helps to conserve memory and processing resources and create better images.
            </p>
            <p>
                Same as before, we calculate barycentric coordinates for pixel (x, y). Now we also find the barycentric coordinates for (x+1, y) and (x, y+1).
                Then, the algorithm differs depending on the sampling method. 
                For level zero sampling, we set level equal to zero and uses the highest resolution mipmap to perform pixel sampling.
                For nearest sampling, we calculate mipmap level using the formula given in lecture, and then round the resulting value to get the nearest level.
                For linear sampling, we also calculate mipmap level, but we take the floor of the resulting value to get the lower level.
                Then add one to it to get the higher mipmap level. Perform pixel sampling using each level and do linear interpolation with the results to get the weighted average. 
            </p>
            <p>
                Supersampling is the slowest technique because it not only require multiple samples per pixel, but also at a higher resolution than the final output. 
                Thus, it uses less memory than level sampling but more than pixel sampling. 
                Supersampling generally provides the most antialiasing power because it uses the highest resolution.
                Pixel sampling is the fastest technique and uses the least amount of memory. However, it provides the least antialiasing power.
                Level sampling is the most cost-effective. Although it uses more memory than supersampling because it needs to store mipmaps of different levels, 
                it is more efficient by using lower resolution for faraway objects and higher resolution of closer ones that require more details. 
                It is generally a happy medium between pixel sampling and supersampling in providing antialiasing. 
            </p>
            <h4>Level Zero Sampling</h4>
            With level zero sampling and switching pixel sampling methods, the images clearly show that bilinear sampling provides better antialiasing.
            <img src="writeup_img/task6_zero_nearest.png">
            <img src="writeup_img/task6_zero_bilinear.png">

            <h4>Nearest Sampling</h4>
            The L_NEAREST and P_LINEAR combination produced the smoothest image. 
            L_NEAREST blurs the image more and shows less texture details in the pixel inspector because the object selected is farther away. 
            <img src="writeup_img/task6_nearest_nearest.png">
            <img src="writeup_img/task6_nearest_bilinear.png">
    </body>
</html>